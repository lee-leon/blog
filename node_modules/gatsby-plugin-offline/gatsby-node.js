"use strict";

var fs = require("fs");

var precache = require("sw-precache");

var path = require("path");

var slash = require("slash");

var _ = require("lodash");

var cheerio = require("cheerio");

exports.createPages = function (_ref) {
  var actions = _ref.actions;

  if (process.env.NODE_ENV === "production") {
    var createPage = actions.createPage;
    createPage({
      path: "/offline-plugin-app-shell-fallback/",
      component: slash(path.resolve(__dirname + "/app-shell.js"))
    });
  }
};

var s;

var readStats = function readStats() {
  if (s) {
    return s;
  } else {
    s = JSON.parse(fs.readFileSync(process.cwd() + "/public/webpack.stats.json", "utf-8"));
    return s;
  }
};

var getAssetsForChunks = function getAssetsForChunks(chunks, rootDir) {
  return _.flatten(chunks.map(function (chunk) {
    return readStats().assetsByChunkName[chunk];
  })).map(function (assetFileName) {
    return rootDir + "/" + assetFileName;
  });
};

exports.onPostBuild = function (args, pluginOptions) {
  var rootDir = "public"; // Get exact asset filenames for app and offline app shell chunks

  var files = getAssetsForChunks(["app", "webpack-runtime", "component---node-modules-gatsby-plugin-offline-app-shell-js"], rootDir); // load index.html to pull scripts/links necessary for proper offline reload

  var html = fs.readFileSync(path.resolve(process.cwd() + "/" + rootDir + "/index.html")); // party like it's 2006

  var $ = cheerio.load(html); // holds any paths for scripts and links

  var criticalFilePaths = [];
  $("script").filter(function (_, elem) {
    return $(elem).attr("src") !== undefined;
  }).each(function (_, elem) {
    criticalFilePaths.push("" + rootDir + $(elem).attr("src"));
  });
  $("link").filter(function (_, elem) {
    return $(elem).attr("as") !== "script";
  }).each(function (_, elem) {
    criticalFilePaths.push("" + rootDir + $(elem).attr("href"));
  });
  var options = {
    staticFileGlobs: files.concat([rootDir + "/index.html", rootDir + "/manifest.json", rootDir + "/manifest.webmanifest", rootDir + "/offline-plugin-app-shell-fallback/index.html"].concat(criticalFilePaths)),
    stripPrefix: rootDir,
    // If `pathPrefix` is configured by user, we should replace
    // the `public` prefix with `pathPrefix`.
    // See more at:
    // https://github.com/GoogleChrome/sw-precache#replaceprefix-string
    replacePrefix: args.pathPrefix || "",
    navigateFallback: "/offline-plugin-app-shell-fallback/index.html",
    // Only match URLs without extensions.
    // So example.com/about/ will pass but
    // example.com/cheeseburger.jpg will not.
    // We only want the service worker to handle our "clean"
    // URLs and not any files hosted on the site.
    //
    // Regex from http://stackoverflow.com/a/18017805
    navigateFallbackWhitelist: [/^.*([^.]{5}|.html)$/],
    cacheId: "gatsby-plugin-offline",
    // Don't cache-bust JS files and anything in the static directory
    dontCacheBustUrlsMatching: /(.*js$|\/static\/)/,
    runtimeCaching: [{
      // Add runtime caching of images.
      urlPattern: /\.(?:png|jpg|jpeg|webp|svg|gif|tiff|js|woff|woff2)$/,
      handler: "fastest"
    }],
    skipWaiting: true
  };

  var combinedOptions = _.defaults(pluginOptions, options);

  return precache.write("public/sw.js", combinedOptions);
};